# *WIP* Coq Ruleset Builder [Coq v8.13.2]

## Communicating With Coq Data

Use s-expressions generated by https://github.com/ejgallego/coq-serapi.

- https://ejgallego.github.io/coq-serapi/coq-serapi/Serapi/Serapi_protocol/

## Language

- Core: https://coq.inria.fr/refman/language/core/index.html
- Language Extensions: https://coq.inria.fr/refman/language/extensions/index.html

### Document Grammar

```grammar
document ::= sentence*
sentence ::= attributes? command .
           | attributes? {natural:}? query_command .
           | attributes? {top_level_selector:}? ltac_expr [.|...]
           | control_command
```

#### Document Level Static Object-Modification Commands

Like most systems we have primarily the `Definition`/`Theorem`/`Module` objects. All other commands help to build these three kinds of objects in a convenient way, or otherwise modify existing constructions. In general, we can use `def`s to build named versions of these objects at the lowest level, and at higher levels they can be represented by things like `namespace`/`mod` or whatever the decided naming convention is for groups of `def`s. See Coq's internal `\delta`-reduction, to ensure we're doing this right.

Here's a working list of commands:

- All the `Add` commands (TODO: examine them in more detail)
- `Arguments`: modifying an object after its creation
- Assumptions:
    - `Axiom`/`Axioms`/`Conjecture`/`Conjectures`/`Parameter`/`Parameters`
    - `Hypothesis`/`Hypotheses`/`Variable`/`Variables`
    - `Context`
- `Back`/`BackTo`/`Reset` ?? (these are more for interaction)
- `Bind Scope`
- `Delimit Scope`/`Undelimit Scope`
- `Canonical`/`Canonical Structure`
- `Cd` (part of path manipulation)
- `Class`/`Instance`
- `Open Scope`/`Close Scope`
- `Coercion`/`Identity Coercion`/`SubClass`
- `CoFixpoint`/`CoInductive`
- `Fixpoint`/`Function`/`Inductive`/`Functional Scheme`/`Variant`
- `Scheme`/`Combined Scheme`
- `Compute`/`Eval` ?? (these are more for interaction)
- `Constraint`/`Universe`
- `Definition` (`Example` too)
- Theorem Tokens:
    - `Theorem`
    - `Lemma`
    - `Fact`
    - `Remark`
    - `Corollary`
    - `Proposition`
    - `Property`
- `Proof`
- `Create HintDb`
- All the `Declare` commands (TODO: examine them in more detail)
- All the `Derive` commands?
- Modules:
    - `Module`/`Section`/`End`
    - `Module Type`
    - `Module Import`/`Module Export`
    - `Import`/`Export`
    - `Include`/`Include Type`
    - `Declare Module`/`Declare Module Import`/`Declare Module Export`
- `Existing Class`/`Existing Instance`/`Existing Instances` ??
- All the `Extract`/`Extraction` commands ?? (TODO: examine them in more detail)
- All the `Require`/`Load`-related commands (we should use `Require` instead of `Load`)
- `Generalizable` ??
- `Implicit Type`/`Implicit Types`
- Custom Syntax Commands ?? (TODO: should we include these? probably not)
- All the `Let` commands (TODO: consider if we should include these?)
- All the `Ltac`/`Ltac2` commands (TODO: examine them in more detail, separate language)
- `Opaque`/`Transparent`/`Strategy` ??
- `Primitive`/`Register`/`Register Inline`
- `Record`/`Structure`
- `Remove` ?? (NOTE: see `Add` commands)
- `Reserved Notation` may be necessary ??

#### Full Command List

	a	
	Abort	
	About	
	Add	
	Add BinOp	
	Add BinOpSpec	
	Add BinRel	
	Add CstOp	
	Add Field	
	Add InjTyp	
	Add LoadPath	
	Add ML Path	
	Add Morphism	
	Add Parametric Morphism	
	Add Parametric Relation	
	Add PropBinOp	
	Add PropOp	
	Add PropUOp	
	Add Rec LoadPath	
	Add Relation	
	Add Ring	
	Add Saturate	
	Add Setoid	
	Add UnOp	
	Add UnOpSpec	
	Add Zify	
	Admit Obligations	
	Admitted	
	Arguments	
	Axiom	
	Axioms	
	 	
	b	
	Back	
	BackTo	
	Bind Scope	
	 	
	c	
	Canonical Structure	
	Cd	
	Check	
	Class	
	Close Scope	
	Coercion	
	CoFixpoint	
	CoInductive	
	Collection	
	Combined Scheme	
	Comments	
	Compute	
	Conjecture	
	Conjectures	
	Constraint	
	Context	
	Corollary	
	Create HintDb	
	 	
	d	
	Declare Custom Entry	
	Declare Instance	
	Declare Left Step	
	Declare ML Module	
	Declare Module	
	Declare Morphism	
	Declare Reduction	
	Declare Right Step	
	Declare Scope	
	Defined	
	Definition	
	Delimit Scope	
	Derive	
	Derive Dependent Inversion	
	Derive Dependent Inversion_clear	
	Derive Inversion	
	Derive Inversion_clear	
	Drop	
	 	
	e	
	End	
	Eval	
	Example	
	Existential	
	Existing Class	
	Existing Instance	
	Existing Instances	
	Export	
	Extract Constant	
	Extract Inductive	
	Extract Inlined Constant	
	Extraction	
	Extraction Blacklist	
	Extraction Implicit	
	Extraction Inline	
	Extraction Language	
	Extraction Library	
	Extraction NoInline	
	Extraction TestCompile	
	 	
	f	
	Fact	
	Fail	
	Fixpoint	
	Focus	
	From … Require	
	Function	
	Functional Scheme	
	 	
	g	
	Generalizable	
	Goal	
	Grab Existential Variables	
	Guarded	
	 	
	h	
	Hint Constants	
	Hint Constructors	
	Hint Cut	
	Hint Extern	
	Hint Immediate	
	Hint Mode	
	Hint Opaque	
	Hint Resolve	
	Hint Rewrite	
	Hint Transparent	
	Hint Unfold	
	Hint Variables	
	Hint View for	
	Hint View for apply	
	Hint View for move	
	Hypotheses	
	Hypothesis	
	 	
	i	
	Identity Coercion	
	Implicit Type	
	Implicit Types	
	Import	
	Include	
	Include Type	
	Inductive	
	Infix	
	Info	
	Inspect	
	Instance	
	 	
	l	
	Lemma	
	Let	
	Let CoFixpoint	
	Let Fixpoint	
	Load	
	Locate	
	Locate File	
	Locate Library	
	Locate Ltac	
	Locate Module	
	Locate Term	
	Ltac	
	Ltac2	
	Ltac2 Eval	
	Ltac2 external	
	Ltac2 Notation	
	Ltac2 Notation (abbreviation)	
	Ltac2 Set	
	Ltac2 Type	
	 	
	m	
	Module	
	Module Type	
	 	
	n	
	Next Obligation	
	Notation	
	Notation (abbreviation)	
	Number Notation	
	 	
	o	
	Obligation	
	Obligation Tactic	
	Obligations	
	Opaque	
	Open Scope	
	Optimize Heap	
	Optimize Proof	
	 	
	p	
	Parameter	
	Parameters	
	Prenex Implicits	
	Preterm	
	Primitive	
	Print	
	Print All	
	Print All Dependencies	
	Print Assumptions	
	Print Canonical Projections	
	Print Classes	
	Print Coercion Paths	
	Print Coercions	
	Print Custom Grammar	
	Print Debug GC	
	Print Extraction Blacklist	
	Print Extraction Inline	
	Print Firstorder Solver	
	Print Grammar	
	Print Graph	
	Print Hint	
	Print HintDb	
	Print Implicit	
	Print Instances	
	Print Libraries	
	Print LoadPath	
	Print Ltac	
	Print Ltac Signatures	
	Print ML Modules	
	Print ML Path	
	Print Module	
	Print Module Type	
	Print Opaque Dependencies	
	Print Options	
	Print Rewrite HintDb	
	Print Rings	
	Print Scope	
	Print Scopes	
	Print Section	
	Print Strategies	
	Print Strategy	
	Print Table	
	Print Tables	
	Print Transparent Dependencies	
	Print Typing Flags	
	Print Universes	
	Print Visibility	
	Proof	
	Proof `term`	
	Proof using	
	Proof with	
	Property	
	Proposition	
	Pwd	
	 	
	q	
	Qed	
	Quit	
	 	
	r	
	Record	
	Recursive Extraction	
	Recursive Extraction Library	
	Redirect	
	Register	
	Register Inline	
	Remark	
	Remove	
	Remove Hints	
	Remove LoadPath	
	Require	
	Require Export	
	Require Import	
	Reserved Infix	
	Reserved Notation	
	Reset	
	Reset Extraction Blacklist	
	Reset Extraction Inline	
	Reset Initial	
	Reset Ltac Profile	
	Restart	
	 	
	s	
	Save	
	Scheme	
	Search	
	Search (ssreflect)	
	SearchHead	
	SearchPattern	
	SearchRewrite	
	Section	
	Separate Extraction	
	Set	
	Show	
	Show Conjectures	
	Show Existentials	
	Show Goal	
	Show Intro	
	Show Intros	
	Show Lia Profile	
	Show Ltac Profile	
	Show Match	
	Show Obligation Tactic	
	Show Proof	
	Show Universes	
	Show Zify	
	Show Zify Spec	
	Solve All Obligations	
	Solve Obligations	
	Strategy	
	String Notation	
	Structure	
	SubClass	
	 	
	t	
	Tactic Notation	
	Test	
	Theorem	
	Time	
	Timeout	
	Transparent	
	Typeclasses eauto	
	Typeclasses Opaque	
	Typeclasses Transparent	
	 	
	u	
	Undelimit Scope	
	Undo	
	Unfocus	
	Unfocused	
	Universe	
	Unset	
	Unshelve	
	 	
	v	
	Variable	
	Variables	
	Variant

## Calculus of Inductive Constructions

### Conversion Rules

- See: https://coq.inria.fr/refman/language/core/conversion.html#conversion-rules

### Typing Rules

- See: https://coq.inria.fr/refman/language/cic.html

```
					
W-Empty -------------------
	        (WF () ())
```

```
				(E Γ ⊢ T : s) (s ∈ SORT) (x ∉ Γ)
W-Local-Assum ---------------------------------
				  (WF E (Γ :: (x : T)))
```

```
			     (E Γ ⊢ t : T) (x ∉ Γ)
W-Local-Def ------------------------------
			  (WF E (Γ :: (x := t : T)))
```

```
				(E () ⊢ T : s) (s ∈ SORT) (c ∉ E)
W-Global-Assum ---------------------------------
				  (WF (E ; (c : T)) ())
```

```
			     (E () ⊢ t : T) (c ∉ E)
W-Global-Def ------------------------------
			   (WF (E ; (c := t : T)) ())
```

```
			      (WF E Γ) 
Ax-SProp ----------------------------
		   (E Γ ⊢ SProp : (Type 1))
```

```
			     (WF E Γ) 
Ax-Prop ---------------------------
		  (E Γ ⊢ Prop : (Type 1))
```

```
			   (WF E Γ) 
Ax-Set --------------------------
		 (E Γ ⊢ Set : (Type 1))
```

```
			         (WF E Γ) 
Ax-Type -----------------------------------
		  (E Γ ⊢ (Type i) : Type (i + 1))
```

```
	 (WF E Γ) ((x : T) ∈ Γ)
Var ------------------------
		(E Γ ⊢ (x : T))
```

```
	        (WF E Γ) ((x := t : T) ∈ Γ)
Var-Named -------------------------------
		         (E Γ ⊢ (x : T))
```

```
	 		(WF E Γ) ((c : T) ∈ E)
Const -----------------------------------
				(E Γ ⊢ (c : T))
```

```
	        	(WF E Γ) ((c := t : T) ∈ E)
Const-Named -----------------------------------
		        	 (E Γ ⊢ (c : T))
```

```
			 (E Γ ⊢ T : s) (s ∈ SORT) (E (Γ :: (x : T)) ⊢ U : SProp)
Prod-SProp --------------------------------------------------------
				     (E Γ ⊢ (∀ (x : T) U) : SProp)
```

```
			(E Γ ⊢ T : s) (s ∈ SORT) (E (Γ :: (x : T)) ⊢ U : Prop)
Prod-Prop -------------------------------------------------------
				     (E Γ ⊢ (∀ (x : T) U) : Prop)
```

```
		   (E Γ ⊢ T : s) (s ∈ {SProp, Prop, Set}) (E (Γ :: (x : T)) ⊢ U : Set)
Prod-Set ------------------------------------------------------------------------
				             (E Γ ⊢ (∀ (x : T) U) : Set)
```

```
		    (E Γ ⊢ T : s) (s ∈ {SProp, (Type i)}) (E (Γ :: (x : T)) ⊢ U : (Type i))
Prod-Type ---------------------------------------------------------------------------
				             (E Γ ⊢ (∀ (x : T) U) : (Type i))
```

```
	  (E Γ ⊢ (∀ (x : T) U) : s) (s ∈ SORT) (E (Γ :: (x : T)) ⊢ u : U)
Lam -------------------------------------------------------------------
				(E Γ ⊢ (λ (x : T) u) : (∀ (x : T) U))
```

```
	  (E Γ ⊢ f : (∀ (x : T) U)) (E Γ ⊢ t : T)
App -------------------------------------------
			(E Γ ⊢ (f t) : (T { x / t }))
```

```
	  (E Γ ⊢ t : T) (E (Γ :: (x := t : T)) ⊢ u : U)
Let -------------------------------------------------
	  (E Γ ⊢ (let x := t : T in u) : (U { x / t }))
```

#### Impredicative Sets

- See: https://coq.inria.fr/refman/language/cic.html#the-calculus-of-inductive-constructions-with-impredicative-set

```
		   (E Γ ⊢ T : s) (s ∈ SORT) (E (Γ :: (x : T)) ⊢ U : Set)
ProdImp ----------------------------------------------------------
			       (E Γ ⊢ (∀ (x : T) U) : Set)
```

```
		(s ∈ {Prop, Set})
Set1 --------------------------
	   ([ I : Set | I -> s ])
```

```
	   (is_small_inductive_definition I) (s ∈ (Type i))
Set2 ----------------------------------------------------
				([ I : Set | I -> s ])
```

#### Subtyping Rules

- See: https://coq.inria.fr/refman/language/cic.html#subtyping-rules

## Module Typing Rules

- See: https://coq.inria.fr/refman/language/core/modules.html#typing-modules
